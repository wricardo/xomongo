package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"

	"github.com/dave/jennifer/jen"
	. "github.com/dave/jennifer/jen"
	"github.com/fatih/structtag"
	"github.com/urfave/cli/v2"
	"github.com/wricardo/structparser"
)

func generate(c *cli.Context) error {
	parsed, err := structparser.ParseDirectoryWithFilter(c.String("input"), nil)
	if err != nil {
		return err
	}

	if c.Bool("verbose") {
		pretty, _ := json.MarshalIndent(parsed, "", "\t")
		log.Println("parsed structs", string(pretty))
	}

	{
		f := NewFile(c.String("package"))
		f.PackageComment("Code generated by generator, DO NOT EDIT.")

		for _, strct := range parsed {

			metadata := structMetadata{}
			if len(strct.Docs) == 1 {
				if err := json.Unmarshal([]byte(strct.Docs[0]), &metadata); err != nil {
					return err
				}
			}
			if metadata.CollectionName == "" {
				if c.Bool("verbose") {
					log.Printf("skipping %s because there is no collection_name in json struct documentation\n", strct.Name)
				}
				continue
			}

			var idField *structparser.Field
			tagToFieldMap := make(map[string]structparser.Field)

			// validate _id
			for k, v := range strct.Fields {
				if v.Tag != "" {
					val, err := structtag.Parse(v.Tag)
					if err != nil {
						return err
					}
					bsonTag, ok := val.Get("bson")
					if ok != nil {
						return fmt.Errorf("field %s on struct %s has no bson tag", strct.Name, v.Name)
					}
					if bsonTag.Name == "" {
						return fmt.Errorf("field %s on struct %s has invalid bson tag. The first part of the tag cannot be empty. It may be - for ignored field, but not empty", strct.Name, v.Name)
					}
					if bsonTag.Name == "_id" {
						idField = &strct.Fields[k]
					}
					tagToFieldMap[bsonTag.Name] = strct.Fields[k]
				}
			}

			// repository struct
			repositoryName := strct.Name + "Repository"
			f.Type().Id(repositoryName).Struct(
				Id("db").Id("*mongo.Database"),
			)

			receiverId := "x"
			structReceiver := Id(receiverId).Id("*" + repositoryName)

			//constructor
			f.Func().Id("New" + repositoryName).Params(Id("db").Op("*").Qual("go.mongodb.org/mongo-driver/mongo", "Database")).Op("*").Id(repositoryName).Block(
				Return(Op("&").Id(repositoryName).Values(Dict{
					Id("db"): Id("db"),
				})),
			)

			// getColletion
			fn := f.Func().Params(structReceiver).Id("getCollection").Params().Op("*").Id("mongo.Collection")
			fn.Block(
				Return(Id(receiverId + ".db.Collection").Params(Lit(metadata.CollectionName))),
			)
			inputName := "input"

			// insert
			fn = f.Func().Params(structReceiver).Id("Insert").Params(Id("ctx").Qual("context", "Context"), Id(inputName).Op("*").Id(strct.Name)).Id("error")
			fn.BlockFunc(func(g *Group) {
				g.If(
					Id(inputName + ".ID.IsZero").Call(),
				).Block(
					Id(inputName+".ID").Op("=").Qual("go.mongodb.org/mongo-driver/bson/primitive", "NewObjectID").Call(),
				)
				g.If(
					Id(inputName + ".CreatedAt.IsZero").Call(),
				).Block(
					Id(inputName+".CreatedAt").Op("=").Qual("time", "Now").Call(),
				)

				g.If(
					List(Id("res"), Err()).Op(":=").Id(receiverId).Dot("getCollection").Call().Dot("InsertOne").Call(List(Id("ctx"), Id(inputName))),
					Err().Op("!=").Nil(),
				).Block(
					Return(Err()),
				).Else().If(
					Id("res").Dot("InsertedID").Op("!=").Nil(),
				).Block(
					Return(Nil()),
				)
				g.Return(Nil())

			})

			// getPrimitive
			if idField != nil {
				fn = f.Func().Params(structReceiver).Id("GetPrimitive").Params(Id("ctx").Qual("context", "Context"), Id(inputName).Id(idField.Type)).Parens(List(Op("*").Id(strct.Name), Error()))
				fn.BlockFunc(func(g *Group) {
					g.Id("res").Op(":=").Id(strct.Name).Values()
					g.Err().Op(":=").Id(receiverId).Dot("getCollection").Call().Dot("FindOne").Call(Id("ctx"), Qual("go.mongodb.org/mongo-driver/bson", "D").Values(fieldToBson(*idField, Id(inputName)))).Dot("Decode").Call(Op("&").Id("res"))
					isErrorNoDocuments(g)
					g.Return(Op("&").Id("res"), Nil())
				})
				fn = f.Func().Params(structReceiver).Id("Get").Params(Id("ctx").Qual("context", "Context"), Id(inputName).String()).Parens(List(Op("*").Id(strct.Name), Error()))
				fn.BlockFunc(func(g *Group) {
					g.List(Id("id"), Err()).Op(":=").Qual("go.mongodb.org/mongo-driver/bson/primitive", "ObjectIDFromHex").Call(Id(inputName))
					isErrorReturnNilErr(g)
					g.Return(Id(receiverId).Dot("GetPrimitive").Call(Id("ctx"), Id("id")))
				})
			}

			// listAll
			fn = f.Func().Params(structReceiver).Id("ListAll").Params(Id("ctx").Qual("context", "Context")).Parens(List(Index().Id(strct.Name), Error()))
			fn.BlockFunc(func(g *Group) {
				g.List(Id("cur"), Err()).Op(":=").Id(receiverId).Dot("getCollection").Call().Dot("Find").Call(Id("ctx"), Qual("go.mongodb.org/mongo-driver/bson", "D").Values())
				isErrorReturnNilErr(g)
				g.Id("res").Op(":=").Index().Id(strct.Name).Values()
				g.If(Err().Op(":=").Id("cur").Dot("All").Call(Id("ctx"), Op("&").Id("res")).Op(";").Id("err").Op("!=").Nil()).Block(
					Return(Nil(), Err()),
				)
				g.Return(Id("res"), Nil())
			})

			file, err := os.OpenFile(c.String("output"), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0755)
			if err != nil {
				return err
			}
			defer file.Close()

			if c.Bool("verbose") {
				f.Render(os.Stdout)
			}
			err = f.Render(file)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func isErrorNoDocuments(g *Group) *Statement {
	return isError(
		g,
		If(Err().Op("==").Qual("go.mongodb.org/mongo-driver/mongo", "ErrNoDocuments")).Block(
			Return(Nil(), Nil()),
		),
		Return(Nil(), Nil()),
	)
}

func isError(g *Group, codes ...Code) *jen.Statement {
	return g.If(Err().Op("!=").Nil()).Block(codes...)
}

func isErrorReturnNilErr(g *Group) *jen.Statement {
	return g.If(Err().Op("!=").Nil()).Block(Return(Nil(), Err()))
}

func fieldToBson(field structparser.Field, value *jen.Statement) *jen.Statement {
	return Values(List(
		Lit(getBsonNameFromField(field)), value,
	))
}

func getBsonNameFromField(field structparser.Field) string {
	val, err := structtag.Parse(field.Tag)
	if err != nil {
		panic(err)
	}
	val2, err := val.Get("bson")
	if err != nil {
		panic(err)
	}
	return val2.Name
}

type structMetadata struct {
	CollectionName string `json:"collection_name"`
}
